// Naive Gillespie simulation library.

// Copyright snsinfu 2020.
// Distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef INCLUDED_SNSINFU_GSP_HPP
#define INCLUDED_SNSINFU_GSP_HPP

#include <cstddef>
#include <memory>
#include <ostream>
#include <random>
#include <vector>


namespace gsp
{
    // FRAMEWORK -------------------------------------------------------------

    using std::size_t;


    // A `state` object represents an instantaneous state of simulated system.
    struct state
    {
        // Number of molecules of each species.
        std::vector<int> species;

        // Global time.
        double time = 0;
    };


    template<typename Char, typename Tr>
    std::basic_ostream<Char, Tr>&
    operator<<(std::basic_ostream<Char, Tr>& os, gsp::state const& state)
    {
        using sentry_type = typename std::basic_ostream<Char, Tr>::sentry;

        if (sentry_type sentry{os}) {
            os << state.time;
            for (auto const species : state.species) {
                os << os.widen(' ') << species;
            }
        }
        return os;
    }


    // A `change` object represents a change of single species caused by a
    // reaction.
    //
    // A single reaction may cause multiple changes to various species. In this
    // codebase, we call all the changes caused by a reaction "changeset."
    //
    struct change
    {
        // Index of the affected species in the state object.
        size_t species;

        // Change of the number of molecules.
        int amount;
    };


    // Abstract base class that models a single type of reaction.
    class reaction
    {
    public:
        virtual ~reaction() = default;

        // Returns the species this reaction depends on.
        virtual std::vector<size_t> dependency() const = 0;

        // Returns all the changes caused by a single occurrence of this
        // reaction given system state.
        virtual std::vector<gsp::change> changeset(gsp::state const& state) const = 0;

        // Returns the rate of this reaction given system state.
        virtual double rate(gsp::state const& state) const = 0;
    };


    // A class for driving Gillespie simulation.
    class simulation
    {
    public:
        // Constructor initializes a simulation.
        //
        // Simulation state is initialized to `init`. Especially, the number of
        // species is set to `init.species.size()`.
        //
        explicit simulation(gsp::state const& init)
            : _state{init}
        {
            auto const species_count = init.species.size();
            _dependants.resize(species_count);
        }

        // Returns the current state of the simulated system.
        gsp::state const& state() const
        {
            return _state;
        }

        // Adds single type of reaction to the simulation.
        //
        // Returns the index number associated to the reaction. The index
        // number will be returned by the `step` function when `reaction` is
        // chosen in a Gillespie step.
        //
        template<typename Reaction>
        size_t add_reaction(Reaction const& reaction)
        {
            size_t const reaction_id = _reactions.size();
            _reactions.push_back(std::make_unique<Reaction>(reaction));

            _rates.push_back(reaction.rate(_state));
            _rate_sum += _rates.back();

            for (auto const species : reaction.dependency()) {
                _dependants[species].push_back(reaction_id);
            }

            return reaction_id;
        }

        // Simulates a single reaction.
        //
        template<typename RNG>
        size_t step(RNG& random)
        {
            // Randomly choose which reaction to happen.
            std::uniform_real_distribution<double> uniform;
            double const rate_threshold = uniform(random) * _rate_sum;
            double rate_cumsum = 0;
            size_t reaction_id = _reactions.size() - 1;

            for (size_t i = 0; i < _reactions.size(); i++) {
                if (_rates[i] == 0) {
                    continue;
                }
                rate_cumsum += _rates[i];
                if (rate_cumsum >= rate_threshold) {
                    reaction_id = i;
                    break;
                }
            }

            // Advance time. NB: We must use the sum of the rates, not the
            // rate of the chosen reaction.
            std::exponential_distribution<double> delay{_rate_sum};
            _state.time += delay(random);

            // Apply changes caused by the reaction.
            //
            // Since reaction rates (usually) depend on the number of species,
            // the changes will invalidate reaction rates cached in the `_rates`
            // member variable. The `invalidation` variable here keeps track
            // of affected reactions.
            auto const& reaction = *_reactions[reaction_id];
            auto const rate = _rates[reaction_id];
            std::vector<size_t> invalidation;

            for (auto const& change : reaction.changeset(_state)) {
                _state.species[change.species] += change.amount;

                invalidation.insert(
                    invalidation.end(),
                    _dependants[change.species].begin(),
                    _dependants[change.species].end()
                );
            }

            std::sort(invalidation.begin(), invalidation.end());
            invalidation.erase(
                std::unique(invalidation.begin(), invalidation.end()),
                invalidation.end()
            );

            // Recompute invalidated reaction rates.
            for (auto const i : invalidation) {
                // XXX: Numerical error accumulates.
                _rate_sum -= _rates[i];
                _rates[i] = _reactions[i]->rate(_state);
                _rate_sum += _rates[i];
            }

            return reaction_id;
        }

    private:
        gsp::state                                  _state;
        std::vector<std::vector<size_t>>            _dependants;
        std::vector<std::unique_ptr<gsp::reaction>> _reactions;
        std::vector<double>                         _rates;
        double                                      _rate_sum = 0;
    };


    // SIMPLE REACTIONNS -----------------------------------------------------

    // Generation of single species at constant rate.
    //
    //      * --> X
    //
    // The corresponding differential equation in the continuous limit is
    //
    //      dX/dt = k
    //
    // where X is the concentration of the species and k is the rate.
    //
    class simple_generation : public gsp::reaction
    {
    public:
        struct params
        {
            size_t species = 0;
            double rate    = 0;
        };

        explicit simple_generation(params const& ps)
            : _species{ps.species}
            , _rate{ps.rate}
        {
        }

        std::vector<size_t> dependency() const override
        {
            return {_species};
        }

        std::vector<gsp::change> changeset(gsp::state const&) const override
        {
            return {gsp::change {_species, 1}};
        }

        double rate(gsp::state const&) const override
        {
            return _rate;
        }

    private:
        size_t _species;
        double _rate;
    };


    // Destruction of single species at constant rate.
    //
    //      X --> *
    //
    // The corresponding differential equation in the continuous limit is
    //
    //      dX/dt = -k X
    //
    // where X is the concentration of the species and k is the rate.
    //
    class simple_decay : public gsp::reaction
    {
    public:
        struct params
        {
            size_t species;
            double rate;
        };

        explicit simple_decay(params const& ps)
            : _species{ps.species}
            , _rate{ps.rate}
        {
        }

        std::vector<size_t> dependency() const override
        {
            return {_species};
        }

        std::vector<gsp::change> changeset(gsp::state const&) const override
        {
            return {gsp::change {_species, -1}};
        }

        double rate(gsp::state const& state) const override
        {
            return double(state.species[_species]) * _rate;
        }

    private:
        size_t _species;
        double _rate;
    };


    // Transformation of single species (reactant) to another species (product).
    //
    //      X --> Y
    //
    // The corresponding differential equation in the continuous limit is
    //
    //      dX/dt = -k X
    //      dY/dt = k X
    //
    // where X is the concentration of the reactant, Y is the conncentration
    // of the product and k is the rate.
    //
    class simple_transformation : public gsp::reaction
    {
    public:
        struct params
        {
            size_t reactant;
            size_t product;
            double rate;
        };

        explicit simple_transformation(params const& ps)
            : _reactant{ps.reactant}
            , _product{ps.product}
            , _rate{ps.rate}
        {
        }

        std::vector<size_t> dependency() const override
        {
            return {_reactant};
        }

        std::vector<gsp::change> changeset(gsp::state const&) const override
        {
            return {
                gsp::change {_reactant, -1},
                gsp::change {_product, 1},
            };
        }

        double rate(gsp::state const& state) const override
        {
            return double(state.species[_reactant]) * _rate;
        }

    private:
        size_t _reactant;
        size_t _product;
        double _rate;
    };


    // Association of two species (reactants) into a complex species (product).
    //
    //      X + Y --> Z
    //
    // The corresponding differential equations in the continuous limit is
    //
    //      dX/dt = -k X Y
    //      dY/dt = -k X Y
    //      dZ/dt = k X Y
    //
    // where X and Y are the concentration of the reactants, Z is the
    // conncentration of the product and k is the rate.
    //
    class simple_association : public gsp::reaction
    {
    public:
        struct param
        {
            size_t reactant1;
            size_t reactant2;
            size_t product;
            double rate;
        };

        simple_association(param const& ps)
            : _reactant1{ps.reactant1}
            , _reactant2{ps.reactant2}
            , _product{ps.product}
            , _rate{ps.rate}
        {
        }

        std::vector<size_t> dependency() const override
        {
            return {_reactant1, _reactant2};
        }

        std::vector<gsp::change> changeset(gsp::state const&) const override
        {
            return {
                gsp::change {_reactant1, -1},
                gsp::change {_reactant2, -1},
                gsp::change {_product, 1},
            };
        }

        double rate(gsp::state const& state) const override
        {
            return _rate * double(state.species[_reactant1] * state.species[_reactant2]);
        }

    private:
        size_t _reactant1;
        size_t _reactant2;
        size_t _product;
        double _rate;
    };


    // Dissociation of a complex species (reactant) into two species (products).
    //
    //      X --> Y + Z
    //
    // The corresponding differential equation in the continuous limit is
    //
    //      dX/dt = -k X
    //      dY/dt = k X
    //      dZ/dt = k X
    //
    // where X is the concentration of the reactant, Y and Z are the
    // concentration of the products and k is the rate.
    //
    class simple_dissociation : public gsp::reaction
    {
    public:
        struct param
        {
            size_t reactant;
            size_t product1;
            size_t product2;
            double rate;
        };

        simple_dissociation(param const& ps)
            : _reactant{ps.reactant}
            , _product1{ps.product1}
            , _product2{ps.product2}
            , _rate{ps.rate}
        {
        }

        std::vector<size_t> dependency() const override
        {
            return {_reactant};
        }

        std::vector<gsp::change> changeset(gsp::state const&) const override
        {
            return {
                gsp::change {_reactant, -1},
                gsp::change {_product1, 1},
                gsp::change {_product2, 1},
            };
        }

        double rate(gsp::state const& state) const override
        {
            return _rate * double(state.species[_reactant]);
        }

    private:
        size_t _reactant;
        size_t _product1;
        size_t _product2;
        double _rate;
    };


    // MEDIATED REACTIONS ----------------------------------------------------

    // Generation of a species with a linear catalyst.
    //
    //      * + Y --> X + Y
    //
    // The corresponding differential equation in the continuous limit is
    //
    //      dX/dt = k Y
    //
    // where X is the concentration of the reactant, Y is the concentration of
    // the catalyst and k is the rate.
    //
    class linear_mediated_generation : public gsp::reaction
    {
    public:
        struct param
        {
            size_t species;
            double rate;
            size_t mediator;
        };

        linear_mediated_generation(param const& ps)
            : _species{ps.species}
            , _rate{ps.rate}
            , _mediator{ps.mediator}
        {
        }

        std::vector<size_t> dependency() const override
        {
            return {_mediator};
        }

        std::vector<gsp::change> changeset(gsp::state const&) const override
        {
            return {gsp::change {_species, 1}};
        }

        double rate(gsp::state const& state) const override
        {
            return _rate * double(state.species[_mediator]);
        }

    private:
        size_t _species;
        double _rate;
        size_t _mediator;
    };


    // Destruction of a species with a linear catalyst.
    //
    //      X + Y --> * + Y
    //
    // The corresponding differential equation in the continuous limit is
    //
    //      dX/dt = -k X Y
    //
    // where X is the concentration of the reactant, Y is the concentration of
    // the catalyst and k is the rate.
    //
    class linear_mediated_decay : public gsp::reaction
    {
    public:
        struct param
        {
            size_t species;
            double rate;
            size_t mediator;
        };

        linear_mediated_decay(param const& ps)
            : _species{ps.species}
            , _rate{ps.rate}
            , _mediator{ps.mediator}
        {
        }

        std::vector<size_t> dependency() const override
        {
            return {_species, _mediator};
        }

        std::vector<gsp::change> changeset(gsp::state const&) const override
        {
            return {gsp::change {_species, -1}};
        }

        double rate(gsp::state const& state) const override
        {
            return _rate * double(state.species[_species] * state.species[_mediator]);
        }

    private:
        size_t _species;
        double _rate;
        size_t _mediator;
    };
}

#endif
